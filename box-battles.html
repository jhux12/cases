<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Box Battles | Pullz.gg</title>

  <link rel="stylesheet" href="styles/main.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

  <!-- Tailwind (CDN) -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- Firebase compat (assumes app is initialized elsewhere on the page/app) -->
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>
    <script src="scripts/firebase-config.js"></script>
    <script src="https://js.stripe.com/v3/"></script>

    <!-- Site global UI loaders (adjust paths if needed) -->
    <script defer src="scripts/header.js"></script>
    <script defer src="scripts/navbar.js"></script>
    <script defer src="scripts/footer.js"></script>
  <!-- PackOpener spinner library -->
  <script defer src="pack-opener/spinner.js"></script>

  <style>
    /* Minimal reel host styles; rest via Tailwind */
    .reel-host { position: relative; overflow: hidden; }
    .center-marker {
      position: absolute;
      top: 0;
      bottom: 0;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      flex-direction: column;
      align-items: center;
      pointer-events: none;
    }
    .center-marker .marker-line {
      flex: 1;
      width: 2px;
      background: linear-gradient(#8b5cf6,#3b82f6);
      box-shadow: 0 0 6px #8b5cf6;
    }
    .center-marker .marker-arrow {
      width: 0;
      height: 0;
      border-left: 12px solid transparent;
      border-right: 12px solid transparent;
    }
    .center-marker .marker-arrow.top { border-top: 12px solid #cbd5e1; }
    .center-marker .marker-arrow.bottom { border-bottom: 12px solid #cbd5e1; }
    .pill{border-radius:9999px;padding:.25rem .6rem;border:1px solid rgba(0,0,0,.1);font-size:.75rem}
    .pill.live{border-color:#22c55e;box-shadow:0 0 0 2px rgba(34,197,94,.2) inset}
    dialog[open]{animation:fadeIn .12s ease-out}
    @keyframes fadeIn{from{opacity:.0;transform:scale(.98)}to{opacity:1;transform:scale(1)}}
    /* Spinner styling – scaled down for Box Battles */
    .reel-host .reel{display:flex;will-change:transform;padding:1rem 0}
    .reel-host .tile{flex:0 0 110px;margin:0 6px;position:relative;background:#2a2f3a;border:1px solid #3a4050;border-radius:12px;padding:4px;box-shadow:0 2px 4px rgba(0,0,0,0.5);color:#f1f5f9;transition:transform .2s,box-shadow .2s}
    .reel-host .tile img{width:100px;height:140px;object-fit:cover;border-radius:8px}
    .reel-host .tile-info{position:absolute;left:0;right:0;bottom:0;background:rgba(0,0,0,.6);font-size:.7rem;padding:2px 4px;border-bottom-left-radius:12px;border-bottom-right-radius:12px}
    .reel-host .tile-info .name{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
    .reel-host .tile-info .price{margin-top:2px;display:flex;align-items:center;justify-content:center;gap:2px;color:#fbbf24}
    .reel-host .tile-info .price img{width:.55rem;height:.55rem}
    .reel-host .tile.win{box-shadow:0 0 0 3px var(--win-color,#FFD36E);border-color:var(--win-color,#FFD36E);animation:flash .6s}
    @keyframes flash{0%,100%{filter:brightness(1)}50%{filter:brightness(1.8)}}
    .reel-host .tile.rarity-common{border-color:#b6bdc9;box-shadow:0 0 0 3px #b6bdc9,0 2px 4px rgba(0,0,0,0.5)}
    .reel-host .tile.rarity-uncommon{border-color:#8FE3C9;box-shadow:0 0 0 3px #8FE3C9,0 2px 4px rgba(0,0,0,0.5)}
    .reel-host .tile.rarity-rare{border-color:#A6C8FF;box-shadow:0 0 0 3px #A6C8FF,0 2px 4px rgba(0,0,0,0.5)}
    .reel-host .tile.rarity-ultra,.reel-host .tile.rarity-ultrarare{border-color:#C9A7FF;box-shadow:0 0 0 3px #C9A7FF,0 2px 4px rgba(0,0,0,0.5)}
    .reel-host .tile.rarity-legendary{border-color:#FFD36E;box-shadow:0 0 0 3px #FFD36E,0 2px 4px rgba(0,0,0,0.5)}
  </style>
</head>
<body class="min-h-screen bg-gray-50 text-gray-900 selection:bg-indigo-200/60">
  <!-- Header / Nav injected -->
  <header></header>

  <main class="mt-24 mx-auto max-w-6xl px-4 py-8 space-y-8">
    <!-- Battle Stage (appears when joined/created) -->
    <section id="battle-stage" class="hidden bg-white border border-gray-200 rounded-2xl p-4">
      <p id="stage-status" class="text-indigo-300/80 mb-2 text-center" aria-live="polite"></p>
      <div id="stage-scoreboard" class="grid grid-cols-2 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4"></div>
      <aside id="join-aside" class="mt-4"></aside>
    </section>

    <!-- Hero -->
    <section class="flex flex-col md:flex-row items-start md:items-center justify-between gap-4">
      <div>
        <h1 class="text-3xl md:text-4xl font-extrabold tracking-tight">Box Battles</h1>
        <p class="text-gray-600 mt-1">Winner takes all. Spin across N rounds — highest total wins the cost.</p>
      </div>
      <div class="flex items-center gap-3">
        <button id="create-battle-btn" class="px-5 py-2 rounded-xl bg-gradient-to-r from-indigo-500 to-blue-500 hover:from-indigo-400 hover:to-blue-400 shadow-lg shadow-indigo-500/20">
          + Create Battle
        </button>
        <a href="#previous-battles" class="text-gray-600 hover:text-gray-900 underline underline-offset-4">Previous Battles</a>
      </div>
    </section>

    <!-- Two-column lists -->
    <section class="grid grid-cols-1 lg:grid-cols-3 gap-6">
      <!-- Open Battles -->
      <div class="lg:col-span-2 bg-white border border-gray-200 rounded-2xl p-4">
        <header class="flex items-center justify-between mb-3">
          <h2 class="text-lg font-semibold">Open Battles</h2>
          <form id="filters-form" class="hidden md:flex items-center gap-2 text-sm">
            <input class="bg-white rounded-lg px-3 py-1.5 border border-gray-300 placeholder-gray-400" placeholder="Min value"/>
            <select class="bg-white rounded-lg px-3 py-1.5 border border-gray-300">
              <option>Any seats</option><option>2</option><option>3</option><option>4</option>
            </select>
          </form>
        </header>
        <div id="battle-list" class="space-y-3"></div>
      </div>

      <!-- My Battles -->
      <aside class="bg-white border border-gray-200 rounded-2xl p-4">
        <header class="flex items-center justify-between mb-3">
          <h2 class="text-lg font-semibold">My Battles</h2>
          <span id="my-battles-count" class="text-sm text-gray-500"></span>
        </header>
        <div id="my-battles" class="space-y-3"></div>
      </aside>
    </section>

    <!-- Previous Battles -->
    <section id="previous-battles" class="bg-white border border-gray-200 rounded-2xl p-4">
      <header class="flex items-center justify-between mb-3">
        <h2 class="text-lg font-semibold">Previous Battles</h2>
        <span class="text-sm text-gray-500">Latest 5</span>
      </header>
      <div id="previous-battles-list" class="space-y-3"></div>
    </section>
  </main>

  <!-- Footer injected -->
  <footer></footer>

  <!-- Create Battle Modal -->
  <dialog id="battle-form" class="bg-white text-gray-900 border border-gray-200 rounded-2xl p-0 w-[min(720px,calc(100vw-2rem))]">
    <form method="dialog" class="p-5">
      <header class="flex items-center justify-between mb-4">
        <h3 class="text-xl font-semibold">Create Battle</h3>
        <button class="px-2 py-1 text-gray-600 hover:text-gray-900" value="cancel">✕</button>
      </header>

      <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
        <div class="md:col-span-2">
          <label class="text-sm text-gray-600">Choose Packs</label>
          <div id="pack-grid" class="mt-2 grid grid-cols-2 sm:grid-cols-3 gap-3 overflow-y-auto max-h-72"></div>
        </div>
        <div class="space-y-3">
          <input id="spin-count" type="hidden" value="0"/>
          <div>
            <label class="text-sm text-gray-600">Players</label>
            <select id="player-count" class="mt-1 w-full bg-white border border-gray-300 rounded-lg px-3 py-2">
              <option value="2">2</option><option value="3">3</option><option value="4" selected>4</option>
            </select>
          </div>
          <div id="selection-summary" class="text-sm text-gray-600">0 boxes selected — Cost: 0</div>
          <button id="create-lobby" class="w-full mt-2 px-4 py-2 rounded-xl bg-gradient-to-r from-indigo-500 to-blue-500 hover:from-indigo-400 hover:to-blue-400">
            Create Lobby
          </button>
        </div>
      </div>
    </form>
  </dialog>

  <!-- Rewatch Modal -->
  <dialog id="rewatch-modal" class="bg-white text-gray-900 border border-gray-200 rounded-2xl p-0 w-[min(840px,calc(100vw-2rem))]">
    <form method="dialog" class="p-5">
      <header class="flex items-center justify-between mb-4">
        <h3 class="text-xl font-semibold">Rewatch Battle</h3>
        <button class="px-2 py-1 text-gray-600 hover:text-gray-900" value="cancel">✕</button>
      </header>
      <div id="rewatch-stage" class="reel-host rounded-xl border border-gray-200 bg-gray-100 p-3">
        <div id="rewatch-reel" class="reel h-40 md:h-48 flex items-center"></div>
        <div class="center-marker z-10">
          <span class="marker-arrow top"></span>
          <span class="marker-line"></span>
          <span class="marker-arrow bottom"></span>
        </div>
      </div>
      <div class="mt-4 flex items-center gap-3">
        <button id="rewatch-play" class="px-4 py-1.5 rounded-lg bg-gray-100 hover:bg-gray-200">Play</button>
        <input id="rewatch-progress" type="range" min="0" value="0" class="w-full"/>
      </div>
    </form>
  </dialog>

  <!-- Page logic -->
  <script type="module">
    import { renderSpinner, spinToPrize, getRarityColor } from './scripts/spinner.js';
    const BOT_AVATAR_URL = 'https://firebasestorage.googleapis.com/v0/b/cases-e5b4e.firebasestorage.app/o/ChatGPT%20Image%20Aug%2010%2C%202025%2C%2011_08_17%20PM.png?alt=media&token=4950e6a0-1cf9-4c7b-aa56-686dc42693a8';
    /***** DESCRIPTION FOR CODEX *****
     - Build a Winner-Takes-All Box Battles page that:
       1) Lists open battles (#battle-list) and my battles (#my-battles).
       2) Lets user create a lobby via #battle-form (choose packs; spinCount equals number selected; choose playerCount).
       3) On join, if seats < max at countdown end, fill with bots.
       4) Run N rounds where all players spin simultaneously using individual spinners:
          - For each round: compute deterministic index for each player,
            render their spinners and spin together,
            then update totals and store pulls in Firestore.
       5) After last round, highest total wins the cost. Persist winner + pulls.
       6) Previous Battles list shows last 20 finished; Rewatch modal replays stored indexes quickly.
     - Keep Firebase compat. Assume firebase.initializeApp(...) already exists globally.
     - DO NOT rename these hook IDs: 
       #create-battle-btn #battle-form #pack-grid #spin-count #player-count
       #battle-list #my-battles #previous-battles #rewatch-modal #rewatch-stage
       #battle-stage #stage-scoreboard #stage-status #join-aside #filters-form
     *********************************/

    // --- Shortcuts
    const firestore = firebase.firestore();
    const battlesRef = firestore.collection('battles');

    // Resolve the current user via Firebase Auth (fallback guest during development).
    function currentUser(){
      const u = firebase.auth().currentUser;
      if (!u) return null;
      return { uid: u.uid, displayName: u.displayName || (u.email||'User').split('@')[0], avatarUrl: u.photoURL || '' };
    }

    // Fetch available packs + prizes from Firestore with a Realtime Database fallback.
    let _packsCache;
    async function fetchAvailablePacks(){
      if (_packsCache) return _packsCache;
      try {
        let packs = [];

        // Primary: Firestore "packs" collection (or legacy "cases" collection)
        let snap = await firestore.collection('packs').get();
        let docs = snap.docs;
        if (docs.length === 0){
          snap = await firestore.collection('cases').get();
          docs = snap.docs;
        }
        if (docs.length){
          packs = await Promise.all(docs.map(async doc => {
            const data = doc.data() || {};
            const pack = { id: doc.id, name: data.name, image: data.image, price: data.price, prizes: [] };
            if (Array.isArray(data.prizes) && data.prizes.length){
              pack.prizes = data.prizes;
            }else{
              const prizesSnap = await doc.ref.collection('prizes').get();
              pack.prizes = prizesSnap.docs.map(p=> ({ id: p.id, ...p.data() }));
            }
            return pack;
          }));
        }

        // Fallback: Realtime Database "cases" node (mirrors packs.js)
        if (!packs.length){
          const snapRT = await firebase.database().ref('cases').once('value');
          const data = snapRT.val() || {};
          packs = Object.entries(data).map(([id, val]) => ({
            id,
            name: val.name,
            image: val.image,
            price: val.price,
            prizes: Object.entries(val.prizes || {}).map(([pid, pv]) => ({
              id: pid,
              name: pv.name,
              image: pv.image,
              value: pv.value,
              rarity: pv.rarity || pv.tier || '',
              odds: pv.odds || pv.chance || pv.weight || 0
            }))
          }));
        }

        _packsCache = packs;
        return packs;
      } catch(err){
        console.error('fetchAvailablePacks failed', err);
        return [];
      }
    }

    // Deterministic index helper (provably fair or fallback hash).
    const _legacyIndexHelper = window.provablyFairIndex || window.getWinningIndex;
    window.getWinningIndex = function(pack, serverSeed, clientSeed, nonce){
      if (typeof _legacyIndexHelper === 'function'){
        return _legacyIndexHelper(pack, serverSeed, clientSeed, nonce);
      }
      const str = [serverSeed, clientSeed, nonce, pack.id].join('|');
      let h = 2166136261;
      for (let i=0; i<str.length; i++){
        h ^= str.charCodeAt(i);
        h = Math.imul(h, 16777619);
      }
      const x = (h>>>0) / 2**32;
      const prizes = pack.prizes || [];
      const total = prizes.reduce((s,p)=> s + (p.odds || 1), 0);
      let accum = 0;
      const target = x * total;
      for (let i=0;i<prizes.length;i++){
        accum += prizes[i].odds || 1;
        if (target < accum) return i;
      }
      return prizes.length ? prizes.length - 1 : 0;
    };
    const getWinningIndex = window.getWinningIndex;

    // Utilities
    const $ = (s, r=document) => r.querySelector(s);
    const $$ = (s, r=document) => Array.from(r.querySelectorAll(s));
    const sleep = (ms) => new Promise(r=>setTimeout(r, ms));
    function triggerBattleRunner(id, beacon=false){
      const url = `/api/run-battle?battleId=${encodeURIComponent(id)}`;
      if (beacon && navigator.sendBeacon){
        navigator.sendBeacon(url);
      } else {
        fetch(url).catch(()=>{});
      }
    }
    let activeBattleId = null;
    function pingRunner(){
      if (activeBattleId) triggerBattleRunner(activeBattleId, true);
    }
    window.addEventListener('pagehide', pingRunner);
    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'hidden') pingRunner();
    });

    // Render helpers
    function pill(text, extra=''){ return `<span class="pill bg-gray-100 ${extra}">${text}</span>`; }
    function avatar(u){
      const name = typeof u === 'string' ? u : (u?.displayName || '');
      const url = typeof u === 'object' ? (u.isBot ? BOT_AVATAR_URL : u.photoURL) : null;
      if (url) return `<img src="${url}" alt="avatar" class="w-8 h-8 rounded-full object-cover"/>`;
      const init = (name||'U')[0]?.toUpperCase() || 'U';
      return `<div class="w-8 h-8 rounded-full bg-gray-100 grid place-items-center text-sm font-semibold">${init}</div>`;
    }
  function rowCard(inner){ return `<div class="rounded-xl border border-gray-200 bg-white p-3">${inner}</div>`; }

  function renderPackIcons(packs, sizeClass, limit){
    const map = {};
    (packs||[]).forEach(p=>{
      const key = p.id || p.name;
      if(!map[key]) map[key] = { pack: p, count: 0 };
      map[key].count++;
    });
    return Object.values(map)
      .slice(0, limit || Object.keys(map).length)
      .map(({pack, count})=>`
        <div class="relative">
          <img src="${pack.image}" class="${sizeClass} object-cover rounded-md border border-gray-200"/>
          ${count>1 ? `<span class="absolute -top-1 -right-1 w-5 h-5 rounded-full bg-indigo-600 text-white text-[0.625rem] flex items-center justify-center">${count}</span>` : ''}
        </div>`)
      .join('');
  }

    // --- Pack chooser UI
    async function populatePackGrid(){
      const packs = await fetchAvailablePacks();
      const grid = $('#pack-grid'); grid.innerHTML = '';
      packs.forEach(p=>{
        const card = document.createElement('div');
        card.className = 'pack-card rounded-xl border border-gray-200 bg-white p-2 text-center';
        card.dataset.id = p.id;
        card.dataset.name = p.name;
        card.dataset.image = p.image;
        card.dataset.price = p.price;
        card.innerHTML = `
          <img src="${p.image}" class="w-16 h-20 object-cover rounded-md mx-auto"/>
          <div class="mt-2 text-xs flex items-center justify-between">
            <span class="truncate">${p.name}</span>
            <span class="text-gray-500">${p.price}</span>
          </div>
          <div class="mt-2 flex items-center justify-center gap-2">
            <button type="button" class="dec w-6 h-6 rounded bg-gray-100">-</button>
            <input type="number" min="0" value="0" class="qty w-8 bg-transparent text-center"/>
            <button type="button" class="inc w-6 h-6 rounded bg-gray-100">+</button>
          </div>
        `;
        const qty = card.querySelector('.qty');
        card.querySelector('.inc').onclick = ()=>{ qty.value = Number(qty.value||0)+1; updatePackSummary(); };
        card.querySelector('.dec').onclick = ()=>{ qty.value = Math.max(0, Number(qty.value||0)-1); updatePackSummary(); };
        qty.oninput = updatePackSummary;
        grid.appendChild(card);
      });
      updatePackSummary();
    }

    function gatherSelectedPacks(){
      const out = [];
      $$('#pack-grid .pack-card').forEach(card=>{
        const qty = Number(card.querySelector('.qty').value||0);
        if (qty>0){
          const meta = { id:card.dataset.id, name:card.dataset.name, image:card.dataset.image, price:Number(card.dataset.price) };
          for(let i=0;i<qty;i++) out.push(meta);
        }
      });
      return out;
    }

    function updatePackSummary(){
      const packs = gatherSelectedPacks();
      const total = packs.reduce((s,p)=>s+p.price,0);
      $('#selection-summary').textContent = `${packs.length} boxes selected — Cost: ${total}`;
      $('#spin-count').value = packs.length;
    }

    // --- Open/My/Previous lists
      function renderBattleRow(b){
        const live = (b.status==='lobby' || b.status==='countdown') ? pill('LIVE','live') : '';
        const packs = renderPackIcons(b.packs || [], 'w-16 h-20');
        const playerIcons = (b.players||[]).map(p=> avatar(p)).join('');
        const seatCount = `${(b.players?.length || 0)}/${b.maxPlayers}`;
        const canJoin = (b.status==='lobby' || b.status==='countdown') && (b.players?.length||0) < b.maxPlayers;
        const cost = Number(b.cost || 0).toLocaleString();
        const waitingText = canJoin ? 'waiting for players' : '';

        return rowCard(`
          <div class="flex flex-col gap-3">
            <header class="flex items-center justify-between">
              <div class="flex items-center gap-2 text-sm font-semibold">${live}</div>
              <div class="flex items-center text-sm text-gray-700">
                <span class="mr-1 text-gray-500">Battle Cost</span>
                <img src="https://firebasestorage.googleapis.com/v0/b/cases-e5b4e.firebasestorage.app/o/diamond.png?alt=media&token=244f4b80-1832-4c7c-89da-747a1f8457ff" class="w-4 h-4 mr-1" alt="Gem"/>${cost}
              </div>
            </header>
            <div class="flex items-center gap-2">${packs}</div>
            <div class="flex items-center justify-between">
              <div class="flex -space-x-2 items-center">${playerIcons}</div>
              <div class="flex items-center gap-2">
                ${canJoin ? `<button class="join-btn px-4 py-2 rounded-lg bg-gradient-to-r from-indigo-500 to-blue-500 hover:from-indigo-400 hover:to-blue-400 text-white" data-id="${b.id}">Join Battle</button>` : ''}
                <button class="watch-btn px-4 py-2 rounded-lg bg-gray-100 hover:bg-gray-200" data-id="${b.id}">View Battle</button>
                <div class="w-6 h-6 rounded-md bg-gray-100 text-gray-700 text-xs flex items-center justify-center">${seatCount}</div>
              </div>
            </div>
            <div class="text-sm text-gray-500">${waitingText}</div>
          </div>
        `);
      }

      function renderPreviousRow(b){
        const winner = b.winner?.displayName || '—';
        const packs = renderPackIcons(b.packs || [], 'w-8 h-10', 6);
        const cost = Number(b.cost || 0).toLocaleString();
      return rowCard(`
        <div class="flex flex-wrap items-center justify-between gap-3">
          <div class="flex items-center gap-3">${packs}</div>
          <div class="text-sm text-gray-600">Rounds: ${b.spinCount} • Players: ${b.maxPlayers}</div>
          <div class="text-sm">Winner: <span class="font-semibold">${winner}</span></div>
          <div class="flex items-center text-sm text-gray-700"><img src="https://firebasestorage.googleapis.com/v0/b/cases-e5b4e.firebasestorage.app/o/diamond.png?alt=media&token=244f4b80-1832-4c7c-89da-747a1f8457ff" class="w-4 h-4 mr-1" alt="Gem"/>${cost}</div>
          <button class="rewatch-btn px-3 py-1.5 rounded-lg bg-gray-100 hover:bg-gray-200" data-id="${b.id}">Rewatch</button>
        </div>
      `);
    }

    // --- Stage (spinner + scoreboard) — SINGLE shared spinner for live battle
    let countdownInterval, botInterval;
    function renderScoreboard(players, maxPlayers = players.length, status = '', winnerUid) {
      const board = $('#stage-scoreboard');
      const needsBuild = board.children.length !== maxPlayers || board.dataset.mode !== status;

      if (!needsBuild && status === 'spinning') {
        players.forEach((p, i) => {
          const el = board.children[i];
          if (!el) return;
          const outcome = winnerUid ? (p.uid === winnerUid ? 'winner' : 'loser') : '';
          el.dataset.outcome = outcome;
          el.classList.remove('ring-2','ring-yellow-400/80','ring-red-500/60');
          if (outcome === 'winner') el.classList.add('ring-2','ring-yellow-400/80');
          else if (outcome === 'loser') el.classList.add('ring-2','ring-red-500/60');

          const avatarWrap = el.querySelector('.relative');
          const crown = avatarWrap.querySelector('.crown');
          if (outcome === 'winner' && !crown) {
            avatarWrap.insertAdjacentHTML('beforeend', '<img src="https://cdn.jsdelivr.net/gh/twitter/twemoji@14.0.2/assets/svg/1f451.svg" alt="crown" class="crown w-4 h-4 absolute -top-1 -right-1"/>');
          } else if (outcome !== 'winner' && crown) {
            crown.remove();
          }

          const totalEl = el.querySelector('.player-total');
          if (totalEl) totalEl.textContent = Number(p.total || 0).toLocaleString();
        });
        return;
      }

      board.dataset.mode = status;
      const seats = Array.from({ length: maxPlayers }).map((_, i) => players[i]);
      const html = seats.map((p, i) => {
        const total = Number(p?.total || 0).toLocaleString();
        const avatarUrl = p
          ? (p.isBot ? BOT_AVATAR_URL : (p.photoURL || 'https://cdn-icons-png.flaticon.com/128/847/847970.png'))
          : 'https://cdn-icons-png.flaticon.com/128/847/847969.png';
        const textColor = (status === 'lobby' || status === 'countdown') ? (p ? 'text-green-400' : 'text-red-500') : '';
        const statusText = (status === 'lobby' || status === 'countdown') ? (p ? 'Ready' : 'Waiting') : '';
        return `
        <div class="player rounded-xl border border-gray-200 bg-gray-50 p-3 flex flex-col min-w-0${p?'':' opacity-70'}">
          <div class="flex items-center gap-2 mb-2">
            <div class="relative flex-shrink-0">
              <img src="${avatarUrl}" alt="avatar" class="w-8 h-8 rounded-full object-cover"/>
            </div>
            <div class="flex-1 min-w-0">
              <span class="player-name block text-sm truncate">${p?.displayName || ''}</span>
              <div class="flex items-center gap-1 text-xs text-gray-500">
                <img src="https://firebasestorage.googleapis.com/v0/b/cases-e5b4e.firebasestorage.app/o/diamond.png?alt=media&token=244f4b80-1832-4c7c-89da-747a1f8457ff" class="w-3 h-3" alt="Gem"/>
                <span class="player-total">${total}</span>
              </div>
            </div>
          </div>
          <div id="spinner-border-${i}" class="reel-host w-full h-40 border-2 border-gray-200 rounded-lg overflow-hidden">
            <div id="spinner-container-${i}" class="w-full h-full relative">
              ${statusText ? '<div class="absolute inset-0 flex items-center justify-center '+textColor+'">'+statusText+'</div>' : ''}
            </div>
            <div class="center-marker">
              <span class="marker-arrow top"></span>
              <span class="marker-line"></span>
              <span class="marker-arrow bottom"></span>
            </div>
          </div>
        </div>
        `;
      }).join('');
      board.innerHTML = html;
    }

    // After the battle ends show only the winner and every card they claimed
    // from all players.
    async function renderWinnerSummary(b) {
      const packs = await fetchAvailablePacks();
      // Winner takes all: flatten pulls from every participant
      const allPulls = (b.players || []).flatMap(p => p.pulls || []);
      const cards = allPulls.map(pl => {
        const pack = packs.find(pk => pk.id === pl.packId);
        const prize = pack?.prizes?.find(pr => pr.id === pl.prizeId) || {};
        const rarity = (prize.rarity || 'common').toLowerCase().replace(/\s+/g,'');
        const color = getRarityColor(rarity);
        return `
          <li class="flex items-center gap-3 p-2 rounded-lg border bg-gray-50 w-full" style="border-color:${color}" title="${prize.name || ''}">
            <img src="${prize.image}" alt="${prize.name}" class="w-12 h-16 object-contain"/>
            <div class="flex-1 min-w-0">
              <span class="block text-sm truncate">${prize.name || ''}</span>
              <span class="text-xs text-gray-500 flex items-center gap-1"><img src="https://firebasestorage.googleapis.com/v0/b/cases-e5b4e.firebasestorage.app/o/diamond.png?alt=media&token=244f4b80-1832-4c7c-89da-747a1f8457ff" class="w-3 h-3" alt="Gem"/>${(prize.value||0).toLocaleString()}</span>
            </div>
          </li>`;
      }).join('');

      const board = $('#stage-scoreboard');
      board.className = 'flex flex-col items-center gap-4 w-full';
      board.innerHTML = `
        <div class="flex items-center gap-2 text-xl font-semibold">
          <img src="https://cdn.jsdelivr.net/gh/twitter/twemoji@14.0.2/assets/svg/1f451.svg" alt="crown" class="w-6 h-6"/>
          <span>${b.winner?.displayName || ''}</span>
        </div>
        <ul class="w-full space-y-2">${cards}</ul>
        <button id="watch-replay" class="px-4 py-2 rounded-lg bg-indigo-500/80 hover:bg-indigo-500">Watch</button>
      `;

      $('#watch-replay').onclick = () => openRewatch(b, true);
    }

    function renderPackPreview(packs) {
      const overlay = $('#pack-preview');
      if (!overlay) return;
      overlay.innerHTML = packs.map(p => `<img src="${p.image}" alt="${p.name}" class="w-16 h-20 object-cover rounded-md border border-gray-200"/>`).join('');
      overlay.classList.remove('opacity-0','pointer-events-none');
    }

    function hidePackPreview() {
      const overlay = $('#pack-preview');
      if (!overlay) return;
      overlay.classList.add('opacity-0','pointer-events-none');
      setTimeout(() => { overlay.innerHTML = ''; }, 500);
    }

    function startCountdownTimer(b) {
      clearInterval(countdownInterval);
      function tick() {
        const secs = Math.max(0, Math.ceil((b.countdownEndsAt?.toDate() - new Date()) / 1000));
        $('#join-aside').innerHTML = `<div class="text-sm">Starting in <span class="font-semibold">${secs}</span>s</div>`;
        $('#stage-status').textContent = `Starting in ${secs}s`;
        if (secs <= 0) { clearInterval(countdownInterval); maybeFillBotsAndStart(b); }
      }
      tick();
      countdownInterval = setInterval(tick, 1000);
    }
    function startBotTimer(b) {
      clearInterval(botInterval);
      if (!b.botFillAt) return;
      function tick() {
        const secs = Math.max(0, Math.ceil((b.botFillAt.toDate() - new Date()) / 1000));
        $('#join-aside').innerHTML = `Waiting for players… Auto-filling in <span class="font-semibold">${secs}</span>s`;
        if (secs <= 0) { clearInterval(botInterval); maybeFillBotsAndStart(b); }
      }
      tick();
      botInterval = setInterval(tick, 1000);
    }

    // --- Live listeners
    function subscribeLists(){
      battlesRef.orderBy('createdAt','desc').limit(20).onSnapshot(snap=>{
        const me = currentUser();
        const all = []; const mine = []; const finished = [];
        snap.forEach(doc=>{
          const b = {id:doc.id, ...doc.data()};
          all.push(b);
          if (b.status==='finished') finished.push(b);
          if (me && (b.players||[]).some(p=>p.uid===me.uid)) mine.push(b);
        });

        $('#battle-list').innerHTML = all.slice(0,5).map(renderBattleRow).join('') || '<div class="text-gray-500">No battles yet.</div>';
        $('#my-battles').innerHTML = mine.slice(0,5).map(renderBattleRow).join('') || '<div class="text-gray-500">You are not in any battles.</div>';
        $('#my-battles-count').textContent = me ? (mine.length ? `${mine.length}` : '') : '';
        $('#previous-battles-list').innerHTML = finished.slice(0,5).map(renderPreviousRow).join('') || '<div class="text-gray-500">Nothing yet — be the first!</div>';

        // Buttons
        $$('.join-btn').forEach(btn=> btn.onclick = ()=> joinBattle(btn.dataset.id));
        $$('.watch-btn').forEach(btn=> btn.onclick = ()=> showBattle(btn.dataset.id));
        $$('.rewatch-btn').forEach(btn=> btn.onclick = ()=> openRewatch(btn.dataset.id));
      });
    }

    // --- Create / Join / Watch
    async function openCreateModal(){
      await populatePackGrid();
      $('#battle-form').showModal();
    }

    async function createLobby(){
      const me = currentUser();
      if (!me) { alert('Please sign in to create a battle.'); return; }
      const maxPlayers = parseInt($('#player-count').value||4);
      const packs = gatherSelectedPacks();
      if (!packs.length){ alert('Pick at least one pack'); return; }
      const spinCount = packs.length;

      const cost = packs.reduce((s,p)=> s + (p.price||0), 0);

      // Deduct gems
      const balanceRef = firebase.database().ref('users/' + me.uid + '/balance');
      const { committed } = await balanceRef.transaction(bal => {
        if ((bal||0) < cost) return; // abort
        return (bal||0) - cost;
      });
      if (!committed){ alert('Insufficient balance'); return; }

      const b = {
        createdAt: firebase.firestore.FieldValue.serverTimestamp(),
        createdBy: me,
        packs: packs.map(p=>({id:p.id, name:p.name, image:p.image, price:p.price})),
        spinCount, maxPlayers, mode:'winner_takes_all',
        players: [{...me, total:0, pulls:[]}],
        cost, status:'lobby',
        botFillAt: firebase.firestore.Timestamp.fromDate(new Date(Date.now()+60000))
      };

      try {
        const docRef = await battlesRef.add(b);
        triggerBattleRunner(docRef.id);
        $('#battle-form').close();
        showBattle(docRef.id);
      } catch(err){
        await balanceRef.transaction(bal => (bal||0) + cost); // refund on failure
        console.error(err);
        alert('Failed to create battle');
      }
    }

    async function joinBattle(battleId){
      const me = currentUser();
      if (!me) { alert('Please sign in to join battles.'); return; }
      const docRef = battlesRef.doc(battleId);
      const snap = await docRef.get();
      if (!snap.exists){ alert('Battle missing'); return; }
      const battleData = snap.data();
      const cost = battleData.cost || (battleData.packs||[]).reduce((s,p)=> s + (p.price||0), 0);

      // Deduct gems before attempting to join
      const balanceRef = firebase.database().ref('users/' + me.uid + '/balance');
      const { committed } = await balanceRef.transaction(bal => {
        if ((bal||0) < cost) return; // abort
        return (bal||0) - cost;
      });
      if (!committed){ alert('Insufficient balance'); return; }

      let joined = false;
      try {
        await firestore.runTransaction(async (tx)=>{
          const snap = await tx.get(docRef);
          if (!snap.exists) return;
          const b = snap.data();
          if (b.status!=='lobby' && b.status!=='countdown') return;
          const exists = (b.players||[]).some(p=>p.uid===me.uid);
          if (!exists && (b.players?.length||0) < b.maxPlayers){
            b.players.push({...me, total:0, pulls:[]});
            joined = true;
          }
          if (b.players.length === b.maxPlayers){
            b.status='countdown';
            b.countdownEndsAt = firebase.firestore.Timestamp.fromDate(new Date(Date.now()+5000));
            delete b.botFillAt;
          }else{
            b.botFillAt = firebase.firestore.Timestamp.fromDate(new Date(Date.now()+60000));
          }
          tx.set(docRef, b, {merge:true});
        });
      } catch(err){
        await balanceRef.transaction(bal => (bal||0) + cost); // refund
        console.error(err);
        alert('Failed to join battle');
        return;
      }

      if (!joined){
        await balanceRef.transaction(bal => (bal||0) + cost); // refund
        alert('Unable to join battle.');
        return;
      }

      triggerBattleRunner(battleId);
      showBattle(battleId);
    }

    function showBattle(battleId) {
      activeBattleId = battleId;
      $('#battle-stage').classList.remove('hidden');
      $('#stage-scoreboard').innerHTML = '';
      $('#battle-stage').scrollIntoView({ behavior: 'smooth', block: 'start' });
      battlesRef.doc(battleId).onSnapshot(async snap => {
        if (!snap.exists) return;
        const b = { id: snap.id, ...snap.data() };
        if (b.status === 'finished') activeBattleId = null;
        $('#stage-status').textContent = renderStatus(b);

        if (b.status === 'finished') {
          const board = $('#stage-scoreboard');
          board.classList.add('transition-opacity','duration-500','opacity-0');
          await sleep(500);
          await renderWinnerSummary(b);
          board.classList.remove('opacity-0');
        } else {
          renderScoreboard(b.players || [], b.maxPlayers, b.status, b.winner?.uid);
        }

        if (b.status === 'lobby') {
          renderPackPreview(b.packs || []);
          startBotTimer(b);
        }
        else if (b.status === 'countdown') {
          renderPackPreview(b.packs || []);
          startCountdownTimer(b);
        }
        else {
          hidePackPreview();
          clearInterval(botInterval);
          clearInterval(countdownInterval);
          $('#join-aside').innerHTML = '';
        }

        if (b.status === 'spinning' && !window._battleLoopActive) {
          window._battleLoopActive = true;
          await runBattleLoop(b.id);             // runs until finished
          window._battleLoopActive = false;
        }
      });
    }

    function renderStatus(b){
      if (b.status==='lobby') return 'Waiting for players…';
      if (b.status==='countdown') return 'Countdown to start…';
      if (b.status==='spinning'){
        return `Round ${(b.roundIndex||0)+1} of ${b.spinCount}`;
      }
      if (b.status==='finished') return `Winner: ${b.winner?.displayName || ''}`;
      return '';
    }

      async function maybeFillBotsAndStart(b){
        const docRef = battlesRef.doc(b.id);
        let started = false;
        await firestore.runTransaction(async (tx)=>{
          const snap = await tx.get(docRef);
          const data = snap.data();
          if (!data) return;
          const now = new Date();
          if (data.status==='lobby' && data.botFillAt && data.botFillAt.toDate() <= now){
            while ((data.players?.length||0) < data.maxPlayers){
              data.players.push({ uid:'bot-'+Math.random().toString(36).slice(2,8), displayName:'Bot', isBot:true, total:0, pulls:[] });
            }
            data.status = 'countdown';
            data.countdownEndsAt = firebase.firestore.Timestamp.fromDate(new Date(Date.now()+5000));
          } else if (data.status==='countdown' && data.countdownEndsAt && data.countdownEndsAt.toDate() <= now){
            while ((data.players?.length||0) < data.maxPlayers){
              data.players.push({ uid:'bot-'+Math.random().toString(36).slice(2,8), displayName:'Bot', isBot:true, total:0, pulls:[] });
            }
            data.status='spinning';
            data.roundIndex = 0;
            started = true;
          } else {
            return;
          }
          tx.set(docRef, data, {merge:true});
        });
        if (started) triggerBattleRunner(b.id);
      }

    // --- Round-robin engine
    async function runBattleLoop(battleId) {
      const docRef = battlesRef.doc(battleId);
      const packCache = await fetchAvailablePacks();

      for (;;) {
        const snap = await docRef.get();
        if (!snap.exists) return;
        const b = { id: snap.id, ...snap.data() };
        if (b.status !== 'spinning') break;

        const round = b.roundIndex || 0;
        const players = b.players || [];
        const packs = b.packs || [];

        const packMeta = packs[round];
        const full = packCache.find(x => x.id === packMeta.id) || packMeta;

        const indexes = players.map(p => getWinningIndex(full, 'serverSeed', p.uid, `${round}`));

        players.forEach((p, i) => {
          const prize = full.prizes[indexes[i]];
          renderSpinner(full.prizes, prize, false, i);
        });

        for (let i = 0; i < players.length; i++) {
          const container = document.getElementById(`spinner-container-${i}`);
          if (container) {
            const images = Array.from(container.querySelectorAll('img'));
            await Promise.all(images.map(img => img.complete ? Promise.resolve() : new Promise(res => { img.onload = img.onerror = res; })));
          }
        }

        await sleep(500); // small pause before spinning
        await Promise.all(players.map((p, i) => spinToPrize(() => {}, false, i)));

        let grantUid = null;
        let allPulls = [];
        await firestore.runTransaction(async tx => {
          const s = await tx.get(docRef);
          const d = s.data();
          if (!d || d.status !== 'spinning') return;

          const currentRound = d.roundIndex || 0;
          if (currentRound !== round) return; // another runner already advanced

          const dPlayers = d.players || [];
          const indexesTx = dPlayers.map(p => getWinningIndex(full, 'serverSeed', p.uid, `${currentRound}`));

          dPlayers.forEach((P, idx) => {
            const prize = full.prizes[indexesTx[idx]];
            const pull = {
              round: currentRound,
              packId: full.id,
              prizeId: prize.id,
              value: prize.value,
              index: indexesTx[idx],
              at: firebase.firestore.Timestamp.now()
            };
            P.pulls = (P.pulls || []).concat([pull]);
            P.total = (P.total || 0) + (prize.value || 0);
            dPlayers[idx] = P;
          });

          const nextRound = currentRound + 1;
          if (nextRound >= d.spinCount) {
            const ranked = dPlayers.map((p, i) => ({
              ...p,
              highestPull: Math.max(0, ...(p.pulls || []).map(x => x.value || 0)),
              joinOrder: i
            })).sort((a, b) =>
              (b.total || 0) - (a.total || 0) ||
              (b.highestPull || 0) - (a.highestPull || 0) ||
              (a.joinOrder || 0) - (b.joinOrder || 0)
            );
            const top = ranked[0];
            d.winner = { uid: top.uid, displayName: top.displayName, total: top.total };
            d.status = 'finished';
            d.finishedAt = firebase.firestore.FieldValue.serverTimestamp();
            if (!top.isBot && !d.inventoryGranted) {
              d.inventoryGranted = true;
              grantUid = top.uid;
              allPulls = (dPlayers || []).flatMap(pl => pl.pulls || []);
            }
          } else {
            d.roundIndex = nextRound;
          }

          d.players = dPlayers;
          tx.set(docRef, d, { merge: true });
        });

        if (grantUid && allPulls.length) {
          for (const pl of allPulls) {
            const pack = packCache.find(p => p.id === pl.packId);
            const prize = pack?.prizes?.find(pr => pr.id === pl.prizeId);
            if (prize) {
              await firebase.database().ref(`users/${grantUid}/inventory`).push({
                name: prize.name,
                image: prize.image,
                rarity: prize.rarity,
                value: prize.value,
                timestamp: Date.now(),
                sold: false
              });
            }
          }
        }

        await sleep(2000); // longer break between rounds
      }
    }

    // --- Rewatch
    async function openRewatch(battleOrId, embed = false) {
      let b;
      if (typeof battleOrId === 'string') {
        const snap = await battlesRef.doc(battleOrId).get();
        if (!snap.exists) return;
        b = { id: snap.id, ...snap.data() };
      } else {
        b = battleOrId;
      }
      const all = await fetchAvailablePacks();

      if (embed) {
        const board = $('#stage-scoreboard');
        board.className = 'grid grid-cols-2 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4';
        const players = (b.players || []).map(p => ({ ...p, total: 0 }));
        renderScoreboard(players, players.length, 'spinning');

        for (let r = 0; r < (b.spinCount || 0); r++) {
          $('#stage-status').textContent = `Round ${r + 1} of ${b.spinCount}`;

          const pulls = players.map((_, i) => (b.players[i].pulls || []).find(p => p.round === r) || null);

          const packId = pulls.find(pl => pl)?.packId;
          const packMeta = b.packs?.[r];
          const pack = all.find(x => x.id === (packId || packMeta?.id)) || packMeta;
          const prizeList = pack?.prizes || [];

          pulls.forEach((pl, i) => {
            const prize = prizeList[pl?.index || 0];
            renderSpinner(prizeList, prize, false, i);
          });

          for (let i = 0; i < pulls.length; i++) {
            const container = document.getElementById(`spinner-container-${i}`);
            if (container) {
              const images = Array.from(container.querySelectorAll('img'));
              await Promise.all(images.map(img => img.complete ? Promise.resolve() : new Promise(res => { img.onload = img.onerror = res; })));
            }
          }

          await sleep(500);
          await Promise.all(pulls.map((pl, i) => pl ? spinToPrize(() => {}, false, i) : Promise.resolve()));

          pulls.forEach((pl, i) => { if (pl) players[i].total += pl.value || 0; });
          renderScoreboard(players, players.length, 'spinning');
          await sleep(2000);
        }

        $('#stage-status').textContent = `Winner: ${b.winner?.displayName || ''}`;
        await renderWinnerSummary(b);
        return;
      }

      const reel = document.getElementById('rewatch-reel');
      $('#rewatch-modal').showModal();

      if (!reel._spinnerReady) { PackOpener.init({ root: reel, items: [] }); reel._spinnerReady = true; }

      // Chronological sequence by round then join order
      const seq = [];
      for (let r = 0; r < (b.spinCount || 0); r++) {
        for (let t = 0; t < (b.players || []).length; t++) {
          const pl = (b.players[t].pulls || []).find(p => p.round === r);
          if (pl) {
            const pack = all.find(x => x.id === pl.packId);
            seq.push({ pack, index: pl.index });
          }
        }
      }

      let i = 0;
      $('#rewatch-play').onclick = async (e) => {
        e.preventDefault();
        for (; i < seq.length; i++) {
          const step = seq[i];
          PackOpener.setItems(step.pack.prizes);
          await new Promise(r => PackOpener.spinToIndex(step.index, { durationMs: 900, nearMiss: false, onReveal: r }));
          $('#rewatch-progress').value = i + 1;
          await sleep(120);
        }
      };
      $('#rewatch-progress').max = seq.length;
      $('#rewatch-progress').value = 0;
    }

    // --- Wire up UI
    window.addEventListener('DOMContentLoaded', ()=>{
      subscribeLists();
      $('#create-battle-btn').onclick = openCreateModal;
      $('#create-lobby').onclick = (e)=>{ e.preventDefault(); createLobby(); };
      // Clicking outside dialog to close (optional)
      ['battle-form','rewatch-modal'].forEach(id=>{
        const d = document.getElementById(id);
        d?.addEventListener('click',(e)=>{ if(e.target===d) d.close(); });
      });
    });
  </script>
  <script src="scripts/topup.js"></script>
</body>
</html>
